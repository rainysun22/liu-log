[{"content":" 学习参考：https://course.rs/basic/ownership/ownership.html\n所有权原则 Rust中每一个值都被一个变量所拥有，该变量称为值的所有者 一个值同时只能被一个变量所拥有 当所有者（变量）离开作用域范围时，这个值将被丢弃 变量绑定背后的数据交互 part1：未被转移所有权 let x = 5; let y = x; 执行逻辑： 代码首先将5绑定到变量x，接着拷贝x的值赋给y，最终x和y都等于5\n剖析： 整数是 Rust 基本数据类型，是固定大小的简单值，因此这两个值都是通过自动拷贝的方式来赋值的，都被存在栈中，完全无需在堆上分配内存。故不需要所有权转移。\npart2：转移所有权 let s1 = String::from(\u0026#34;hello\u0026#34;); let s2 = s1; 浅谈String： String是一个复杂类型，由存储在栈中的堆指针、字符串长度、字符串容量共同组成。 其中堆指针指向了真实存储字符串内容的堆内存。\n执行逻辑： 将s1指向存储字符串堆内容的指针移动给s2，s1不指向任何数据。即将s1对字符串的所有权转移给s2\n剖析：\n如果拷贝String和存储在堆上的字节数组(深拷贝)给s2，会对性能造成非常大的影响。 如果只拷贝String本身非常快，因为在64位机器上就拷贝了8字节的指针，8字节的长度，8字节的容量，总计24字节。但是这样s1和s2会同时指向一个字节数组，即一个值有两个所有者。 假设一个值可以拥有两个所有者，当变量离开作用域时，Rust会自动调用drop函数清理变量的堆内存，由于两个变量指向了同一个位置，当s1和s2离开作用域时，它们都会尝试释放相同的内存，即二次释放。 故Rust采用类似浅拷贝的方式，同时使s1无效，这个操作被称为移动 注意： s1的所有权被转移给s2后，s1无效，这时如果使用s1会发生错误。\nlet s1 = String::from(\u0026#34;hello\u0026#34;); let s2 = s1; println!(\u0026#34;{}, world!\u0026#34;, s1); // Error part3：引用 let x: \u0026amp;str = \u0026#34;hello, world\u0026#34;; let y = x; println!(\u0026#34;{},{}\u0026#34;,x,y); 浅析\u0026amp;str： 这是字符串字面量的类型，被硬编码到程序中的字符串值。\n执行过程： x引用了存储在二进制可执行文件中的字符串，并没有持有所有权。故let y = x仅仅对该引用进行了拷贝，此时y和x都引用了同一个字符串。\n和part2的区别： String的例子中s1持有了通过String::from函数创建的值的所有权，在这个例子中，x只是引用了存储在二进制可执行文件中的字符串，并没有持有所有权。\npart4：克隆(深拷贝) let s1 = String::from(\u0026#34;hello\u0026#34;); let s2 = s1.clone(); println!(\u0026#34;s1 = {}, s2 = {}\u0026#34;, s1, s2); // Success 注意：Rust永远不会自动创建数据的深拷贝\n执行过程： 使用clone函数，s2完整复制了s1的数据。没有发生所有权转移。\n可以自动拷贝的类型 如果一个类型拥有Copy特征，一个旧的变量在被赋值给其他变量后仍然可用，也就是赋值的过程即是拷贝的过程\n所有整数类型，比如 u32 布尔类型，bool，它的值是 true 和 false 所有浮点数类型，比如 f64 字符类型，char 元组，当且仅当其包含的类型也都是 Copy 的时候。比如，(i32, i32) 是 Copy 的，但 (i32, String) 就不是 不可变引用 \u0026amp;T 函数传值和返回 将值传递给函数，一样会发生 移动 或者 复制\nfn main() { let s = String::from(\u0026#34;hello\u0026#34;); // s 进入作用域 takes_ownership(s); // s 的值移动到函数里 ... // ... 所以到这里不再有效 let x = 5; // x 进入作用域 makes_copy(x); // x 应该移动函数里， // 但 i32 是 Copy 的，所以在后面可继续使用 x } // 这里, x 先移出了作用域，然后是 s。但因为 s 的值已被移走， // 所以不会有特殊操作 fn takes_ownership(some_string: String) { // some_string 进入作用域 println!(\u0026#34;{}\u0026#34;, some_string); } // 这里，some_string 移出作用域并调用 `drop` 方法。占用的内存被释放 fn makes_copy(some_integer: i32) { // some_integer 进入作用域 println!(\u0026#34;{}\u0026#34;, some_integer); } // 这里，some_integer 移出作用域。不会有特殊操作 同样的，函数返回值也有所有权\nfn main() { let s1 = gives_ownership(); // gives_ownership 将返回值 // 移给 s1 let s2 = String::from(\u0026#34;hello\u0026#34;); // s2 进入作用域 let s3 = takes_and_gives_back(s2); // s2 被移动到 // takes_and_gives_back 中, // 它也将返回值移给 s3 } // 这里, s3 移出作用域并被丢弃。s2 也移出作用域，但已被移走， // 所以什么也不会发生。s1 移出作用域并被丢弃 fn gives_ownership() -\u0026gt; String { // gives_ownership 将返回值移动给 // 调用它的函数 let some_string = String::from(\u0026#34;hello\u0026#34;); // some_string 进入作用域. some_string // 返回 some_string 并移出给调用的函数 } // takes_and_gives_back 将传入字符串并返回该值 fn takes_and_gives_back(a_string: String) -\u0026gt; String { // a_string 进入作用域 a_string // 返回 a_string 并移出给调用的函数 } ","permalink":"http://localhost:1313/posts/rust%E7%AC%94%E8%AE%B0--003-%E6%89%80%E6%9C%89%E6%9D%83/","summary":"\u003cblockquote\u003e\n\u003cp\u003e学习参考：\u003ca href=\"https://course.rs/basic/ownership/ownership.html\"\u003ehttps://course.rs/basic/ownership/ownership.html\u003c/a\u003e\u003c/p\u003e\u003c/blockquote\u003e\n\u003ch2 id=\"所有权原则\"\u003e所有权原则\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003eRust中每一个值都被一个变量所拥有，该变量称为值的所有者\u003c/li\u003e\n\u003cli\u003e一个值同时只能被一个变量所拥有\u003c/li\u003e\n\u003cli\u003e当所有者（变量）离开作用域范围时，这个值将被丢弃\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"变量绑定背后的数据交互\"\u003e变量绑定背后的数据交互\u003c/h2\u003e\n\u003ch3 id=\"part1未被转移所有权\"\u003epart1：\u003ccode\u003e未被转移所有权\u003c/code\u003e\u003c/h3\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003elet x = 5;\nlet y = x;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003e执行逻辑：\u003c/strong\u003e\n代码首先将\u003cstrong\u003e5\u003c/strong\u003e绑定到变量\u003cstrong\u003ex\u003c/strong\u003e，接着拷贝\u003cstrong\u003ex\u003c/strong\u003e的值赋给\u003cstrong\u003ey\u003c/strong\u003e，最终\u003cstrong\u003ex\u003c/strong\u003e和\u003cstrong\u003ey\u003c/strong\u003e都等于5\u003c/p\u003e","title":"Rust笔记--003 所有权"},{"content":" 学习参考：https://course.rs/basic/base-type/index.html\n1. 数值类型 整数类型 Rust的内置数据类型\n长度 有符号 无符号 8位 i8 u8 16位 i16 u16 32位 i32 u32 64位 i64 u64 128位 i128 u128 视架构而定 isize usize 有符号类型范围：-( 2n-1) ~ 2n - 1 - 1 无符号类型范围：0 ~ 2n-1 isize/usize取决于CPU类型：若CPU是32位的，他俩就是32位的 isize/usize主要应用：用作集合的索引 rust整型默认使用i32 let i = 1 // i是i32类型 数值字面量可以用以下形式书写\n数字字面量 示例 十进制 98_222 十六进制 0xff 八进制 0o77 二进制 0b1111_0000 字节(仅限于u8) b\u0026rsquo;A' 整数溢出 debug模式编译时，rust会检查整型溢出，存在问题则panic 使用--release参数编译时，rust不检查溢出，检测到溢出时按照补码循环溢出的规则处理\n大于该类型最大值的数值会被补码转换成能够支持的对应数字的最小值 let a : u8 = 255; let b = a.wrapping_add(20); // 溢出-\u0026gt;补码 println!(\u0026#34;{}\u0026#34;, b); // 19 显示处理可能的溢出，可以使用标准库针对原始数字类型提供的方法：\n使用wrapping_*方法在所有模式下都按照补码循环溢出规则处理 使用checked_*方法时发生溢出，则返回None值 使用overflowing_*方法返回该值和一个是否存在溢出的布尔值 使用saturating_*方法，可以限定计算后的结果不超过目标类型的最大值或低于最小值 assert_eq!(u8::MAX.saturating_add(127), u8::MAX); 浮点类型 f32和f64，默认为f64 f32类型是单精度浮点型，f64为双精度\n浮点数陷阱：\n浮点数往往是数字的近似表达 浮点数不一定可以比较，例如：HashMap类型存放的key必须实现std::cmp::Eq特征，而f64只实现了std::cmp::PartialEq特征 为了避免以上陷阱，需要遵守以下规则：\n避免在浮点数上测试相等性 当结果在数学上可能存在未定义时，需要格外的小心 assert!(0.1 + 0.2 == 0.3); // 会panic NaN 对于数学上未定义的记过，使用NaN(not a number)来处理，且NaN不能被比较\nlet x = (-42.0_f32).sqrt(); // 对复数取平方根 if x.is_nan() { println!(\u0026#34;未定义的数学行为\u0026#34;) } 数字运算 支持加/减/乘/除/取模\n// 编译器会进行自动推导，给予twenty i32的类型 let twenty = 20; // 类型标注 let twenty_one: i32 = 21; // 通过类型后缀的方式进行类型标注：22是i32类型 let twenty_two = 22i32; // 只有同样类型，才能运算 let addition = twenty + twenty_one + twenty_two; println!(\u0026#34;{} + {} + {} = {}\u0026#34;, twenty, twenty_one, twenty_two, addition); // 对于较长的数字，可以用_进行分割，提升可读性 let one_million: i64 = 1_000_000; println!(\u0026#34;{}\u0026#34;, one_million.pow(2)); // 定义一个f32数组，其中42.0会自动被推导为f32类型 let forty_twos = [ 42.0, 42f32, 42.0_f32, ]; // 打印数组中第一个值，并控制小数位为2位 println!(\u0026#34;{:.2}\u0026#34;, forty_twos[0]); 位运算 运算符 说明 \u0026amp; 位与 相同位置均为1时则为1，否则为0 | 位或 相同位置只要有1时则为1，否则为0 ^ 异或 相同位置不相同则为1，相同则为0 ! 位非 把位中的0和1相互取反，即0置为1，1置为0 \u0026laquo; 左移 所有位向左移动指定位数，右位补0 \u0026raquo; 右移 所有位向右移动指定位数，带符号移动（正数补0，负数补1） 序列(Range) 只支持数字或字符类型\n// 1..5 生成从1到4的连续数字 for i in 1..5 { println!(\u0026#34;{}\u0026#34;,i); } // 1..=5 生成从1到5的连续数字，包含5 for i in 1..=5 { println!(\u0026#34;{}\u0026#34;,i); } // \u0026#39;a\u0026#39;..=\u0026#39;z\u0026#39; 生成从a到z的连续字符，包含z for i in \u0026#39;a\u0026#39;..=\u0026#39;z\u0026#39; { println!(\u0026#34;{}\u0026#34;,i); } 使用As完成类型转换 As可以将一个类型转换成另一个类型，也可以实现诸如将指针转换为地址、地址转换为指针以及将指针转换为其他指针的操作\n有理数和复数 标准库不包含，使用num库\n按照以下步骤来引入 num 库：\n创建新工程 cargo new complex-num \u0026amp;\u0026amp; cd complex-num 在 Cargo.toml 中的 [dependencies] 下添加一行 num = \u0026quot;0.4.0\u0026quot; 将 src/main.rs 文件中的 main 函数替换为下面的代码 运行 cargo run use num::complex::Complex; fn main() { let a = Complex { re: 2.1, im: -1.2 }; let b = Complex::new(11.1, 22.2); let result = a + b; println!(\u0026#34;{} + {}i\u0026#34;, result.re, result.im) } 2. 字符·布尔·单元类型 字符类型(char) 不仅仅是ASCII，还包含所有的Unicode 字符类型占用4个字节\nlet x = \u0026#39;中\u0026#39;; println!(\u0026#34;{}\u0026#34;,std::mem::size_of_val(\u0026amp;x)); // 4 布尔(bool) true和false，占用1个字节\n单元类型 单元类型是() main函数和println!函数的返回值就是单元类型() 可以用()作为map的值，表示不关注value只关注key，不占用任何内存\n补充：无返回值的函数叫发散函数，main函数是有返回值的\n3. 语句和表达式 语句 执行一些操作但不会返回一个值\nlet a = 8; let b: Vec\u0026lt;f64\u0026gt; = Vec::new(); let (a, c) = (\u0026#34;hi\u0026#34;, false); 以上都是语句，完成了一个具体的操作，但没有返回值\n表达式 执行一些操作后返回一个值 表达式不能包含分号! 表达式可以成为语句的一部分\nlet y = 6; // 6是表达式，返回一个6 调用一个函数/宏是表达式，用花括号包裹最终返回一个值的语句块也是表达式，因为他们都会返回一个值\nlet y = { let x = 3; // 语句 x + 1 // 表达式 }; fn ret_unit_type() { let x = 1; // if 语句块也是一个表达式，因此可以用于赋值，也可以直接返回 // 类似三元运算符，在Rust里我们可以这样写 let y = if x % 2 == 1 { \u0026#34;odd\u0026#34; } else { \u0026#34;even\u0026#34; }; // 或者写成一行 let z = if x % 2 == 1 { \u0026#34;odd\u0026#34; } else { \u0026#34;even\u0026#34; }; } 表达式如果不返回任何值，会隐式返回一个()\nassert_eq!(ret_unit_type(), ()) 4. 函数 函数构成 ![[Pasted image 20250215222747.png]]\n函数要点 函数名和变量名使用蛇形命名法，例如 fn add_two() -\u0026gt; {} 函数位置可以随便放，只要有定义就行 每个函数的参数都需要标注类型 fn main() { another_function(5, 6.1); } fn another_function(x: i32, y: f32) { println!(\u0026#34;The value of x is: {}\u0026#34;, x); println!(\u0026#34;The value of y is: {}\u0026#34;, y); } 函数返回 函数返回值就是函数体最后一条表达式的返回值，也可以使用return提前返回\nfn plus_or_minus(x:i32) -\u0026gt; i32 { if x \u0026gt; 5 { return x - 5 // return提前返回 } x + 5 // 表达式作为返回值 } 无返回值，返回单元类型()\n函数没有返回值，返回一个() 通过;结尾的语句返回一个() use std::fmt::Debug; fn report\u0026lt;T: Debug\u0026gt;(item: T) { println!(\u0026#34;{:?}\u0026#34;, item); // 隐式返回() } fn clear(text: \u0026amp;mut String) -\u0026gt; () { // 显式返回() *text = String::from(\u0026#34;\u0026#34;); } 永不返回的发散函数，返回 !\n往往用作导致程序崩溃的函数 fn dead_end() -\u0026gt; ! { panic!(\u0026#34;你已经到了穷途末路，崩溃吧！\u0026#34;); } 下面的函数创建了一个无限循环，该循环永不跳出，因此函数也永不返回： fn forever() -\u0026gt; ! { loop { //... }; } ","permalink":"http://localhost:1313/posts/rust%E7%AC%94%E8%AE%B0--002-%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/","summary":"\u003cblockquote\u003e\n\u003cp\u003e学习参考：\u003ca href=\"https://course.rs/basic/base-type/index.html\"\u003ehttps://course.rs/basic/base-type/index.html\u003c/a\u003e\u003c/p\u003e\u003c/blockquote\u003e\n\u003ch2 id=\"1-数值类型\"\u003e1. 数值类型\u003c/h2\u003e\n\u003ch3 id=\"整数类型\"\u003e整数类型\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eRust的内置数据类型\u003c/code\u003e\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003e长度\u003c/th\u003e\n          \u003cth\u003e有符号\u003c/th\u003e\n          \u003cth\u003e无符号\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e8位\u003c/td\u003e\n          \u003ctd\u003ei8\u003c/td\u003e\n          \u003ctd\u003eu8\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e16位\u003c/td\u003e\n          \u003ctd\u003ei16\u003c/td\u003e\n          \u003ctd\u003eu16\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e32位\u003c/td\u003e\n          \u003ctd\u003ei32\u003c/td\u003e\n          \u003ctd\u003eu32\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e64位\u003c/td\u003e\n          \u003ctd\u003ei64\u003c/td\u003e\n          \u003ctd\u003eu64\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e128位\u003c/td\u003e\n          \u003ctd\u003ei128\u003c/td\u003e\n          \u003ctd\u003eu128\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e视架构而定\u003c/td\u003e\n          \u003ctd\u003eisize\u003c/td\u003e\n          \u003ctd\u003eusize\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cul\u003e\n\u003cli\u003e有符号类型范围：-( 2\u003c!-- raw HTML omitted --\u003en-1\u003c!-- raw HTML omitted --\u003e) ~ 2\u003c!-- raw HTML omitted --\u003en - 1\u003c!-- raw HTML omitted --\u003e - 1\u003c/li\u003e\n\u003cli\u003e无符号类型范围：0 ~ 2\u003c!-- raw HTML omitted --\u003en\u003c!-- raw HTML omitted --\u003e-1\u003c/li\u003e\n\u003cli\u003eisize/usize取决于CPU类型：若CPU是32位的，他俩就是32位的\u003c/li\u003e\n\u003cli\u003eisize/usize主要应用：用作集合的索引\u003c/li\u003e\n\u003cli\u003erust整型默认使用i32\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003elet i = 1 // i是i32类型\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003ccode\u003e数值字面量可以用以下形式书写\u003c/code\u003e\u003c/p\u003e","title":"Rust笔记--002 基本类型"},{"content":" 学习参考：https://course.rs/basic/variable.html\n变量绑定 let a = \u0026#34;hello world\u0026#34; rust最核心的原则：所有权 所有权，简单来讲，任何内存对象都是有主人的，绑定是把\u0026quot;hello world\u0026quot;绑定给一个变量a，让a成为\u0026quot;hello world\u0026quot;的主人 变量的可变性 rust变量在默认情况下是不可变的 通过mut关键字将变量变为可变的 let mut a = 5; a = 6; 创建一个变量却不适用，用下划线_，在模式匹配会用到 let _a = 5; 变量解构 从一个相对复杂的变量中，匹配出该变量的一部分\nlet (a, mut b): (bool,bool) = (true, false); println!(\u0026#34;a = {:?}, b = {:?}\u0026#34;, a, b); 常量 不允许使用mut 默认不可变，自始至终不可变 使用const关键字声明，且值必须进行类型标注 const MAX_POINTS: u32 = 100_000; 变量遮蔽 同名变量：后面声明的会遮蔽掉前面声明的\nlet x = 5; let x = x + 1; // 在main函数的作用域内对之前的x进行遮蔽 { let x = x * 2; // 在当前的花括号作用域内，对之前的x进行遮蔽 println!(\u0026#34;The value of x in the inner scope is: {}\u0026#34;, x); // x = 12 } println!(\u0026#34;The value of x is: {}\u0026#34;, x); // x= 6 let x = x + 1属于新变量，重新分配内存，只不过名字和上一个一摸一样 作用：在某个作用域内之前的变量不需要使用时，可以重复使用变量名字，不用去想取什么名 ","permalink":"http://localhost:1313/posts/rust%E7%AC%94%E8%AE%B0--001-%E5%8F%98%E9%87%8F/","summary":"\u003cblockquote\u003e\n\u003cp\u003e学习参考：\u003ca href=\"https://course.rs/basic/variable.html\"\u003ehttps://course.rs/basic/variable.html\u003c/a\u003e\u003c/p\u003e\u003c/blockquote\u003e\n\u003ch2 id=\"变量绑定\"\u003e变量绑定\u003c/h2\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003elet a = \u0026#34;hello world\u0026#34;\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003erust最核心的原则：\u003cstrong\u003e所有权\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e所有权，简单来讲，任何内存对象都是有主人的，绑定是把\u0026quot;hello world\u0026quot;绑定给一个变量a，让a成为\u0026quot;hello world\u0026quot;的主人\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"变量的可变性\"\u003e变量的可变性\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003erust变量在默认情况下是\u003cstrong\u003e不可变的\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e通过\u003cstrong\u003emut\u003c/strong\u003e关键字将变量变为可变的\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003elet mut a = 5;\na = 6;\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003e创建一个变量却不适用，用下划线_，在\u003cstrong\u003e模式匹配\u003c/strong\u003e会用到\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003elet _a = 5;\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"变量解构\"\u003e变量解构\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003e从一个相对复杂的变量中，匹配出该变量的一部分\u003c/code\u003e\u003c/p\u003e","title":"Rust笔记--001 变量"},{"content":" 链接：https://leetcode.cn/problems/merge-sorted-array/\n题目 给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。\n请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。\n注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。\n示例 输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3\n输出：[1,2,2,3,5,6]\n思路 从后往前合并：\n从 nums1 的第 m-1 个和 nums2 的第 n-1 个元素开始比较\n每次取较大的元素放到 nums1 的末尾（即 nums1[m + n - 1] 开始往前填）\n这样就能避免在合并过程中覆盖掉 nums1 的原始数据\n代码 class Solution { public: void merge(vector\u0026lt;int\u0026gt;\u0026amp; nums1, int m, vector\u0026lt;int\u0026gt;\u0026amp; nums2, int n) { int i = nums1.size(); while (n \u0026gt; 0) { if (m \u0026gt; 0 \u0026amp;\u0026amp; nums1[m - 1] \u0026gt; nums2[n -1]) { nums1[--i] = nums1[--m]; } else { nums1[--i] = nums2[--n]; } } } }; ","permalink":"http://localhost:1313/posts/leetcode88-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/","summary":"\u003cblockquote\u003e\n\u003cp\u003e链接：\u003ca href=\"https://leetcode.cn/problems/merge-sorted-array/\"\u003ehttps://leetcode.cn/problems/merge-sorted-array/\u003c/a\u003e\u003c/p\u003e\u003c/blockquote\u003e\n\u003ch2 id=\"题目\"\u003e题目\u003c/h2\u003e\n\u003cp\u003e给你两个按 \u003cstrong\u003e非递减顺序\u003c/strong\u003e 排列的整数数组 \u003ccode\u003enums1\u003c/code\u003e 和 \u003ccode\u003enums2\u003c/code\u003e，另有两个整数 \u003ccode\u003em\u003c/code\u003e 和 \u003ccode\u003en\u003c/code\u003e ，分别表示 \u003ccode\u003enums1\u003c/code\u003e 和 \u003ccode\u003enums2\u003c/code\u003e 中的元素数目。\u003c/p\u003e\n\u003cp\u003e请你 \u003cstrong\u003e合并\u003c/strong\u003e \u003ccode\u003enums2\u003c/code\u003e 到 \u003ccode\u003enums1\u003c/code\u003e 中，使合并后的数组同样按 \u003cstrong\u003e非递减顺序\u003c/strong\u003e 排列。\u003c/p\u003e","title":"leetcode88 合并两个有序数组"},{"content":" 学习参考：https://hzpt-inet-club.github.io/english-note/guide/grammar.html\n句子成分 ","permalink":"http://localhost:1313/posts/%E6%B5%85%E5%B0%9D%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95--002-%E5%8F%A5%E5%AD%90%E6%88%90%E5%88%86/","summary":"\u003cblockquote\u003e\n\u003cp\u003e学习参考：\u003ca href=\"https://hzpt-inet-club.github.io/english-note/guide/grammar.html\"\u003ehttps://hzpt-inet-club.github.io/english-note/guide/grammar.html\u003c/a\u003e\u003c/p\u003e\u003c/blockquote\u003e\n\u003ch2 id=\"句子成分\"\u003e句子成分\u003c/h2\u003e\n\u003cp\u003e\r\n\u003cdiv class=\"post-img-view\"\u003e\r\n    \u003ca data-fancybox=\"gallery\" href=\"/images/%e4%bb%8e0%e5%bc%80%e5%a7%8b%e5%ad%a6%e8%8b%b1%e8%af%ad%e8%af%ad%e6%b3%95-%e5%8f%a5%e5%ad%90%e6%88%90%e5%88%86.png\"\u003e\r\n        \u003cimg src=\"/images/%e4%bb%8e0%e5%bc%80%e5%a7%8b%e5%ad%a6%e8%8b%b1%e8%af%ad%e8%af%ad%e6%b3%95-%e5%8f%a5%e5%ad%90%e6%88%90%e5%88%86.png\" alt=\"\"  /\u003e\r\n    \u003c/a\u003e\r\n\u003c/div\u003e\r\n\r\n\u003c/p\u003e","title":"浅尝英语语法--002 句子成分"},{"content":" 学习参考：https://hzpt-inet-club.github.io/english-note/guide/grammar.html\n句子的组成部分 主谓宾句型 -\u0026gt; I hit you I -\u0026gt; 主 hit -\u0026gt; 谓 you -\u0026gt; 宾 十大词性 单词是句子的最小组成部分，每个单词都有词性\n代词pron. 指代某个名词的词\n数词num. 跟数字有关的词\n感叹词interj. 表示说话感情的词\n四大实词\n名词n. 表示具体或抽象事物/人物的词\n动词verb 表示动作或状态的词\n形容词adjective 形容名词的词\n对名词有修饰限定作用\n副词adverb 通常交代时间，地点，原因，程度等非核心信息\n可以修饰形容词，动词，副词以及句子\n三大虚词\n冠词art. 介词prep. 出现在名词前，表示名词与其他词的关系\n连词conj. 连接两个词语或句子的词\n词性关系 虚词不能单独作为句子成分的单词，需要跟实词一起才组成了句子成分 四个实词的关系\r","permalink":"http://localhost:1313/posts/%E6%B5%85%E5%B0%9D%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95--001-%E8%AF%8D%E6%80%A7/","summary":"\u003cblockquote\u003e\n\u003cp\u003e学习参考：\u003ca href=\"https://hzpt-inet-club.github.io/english-note/guide/grammar.html\"\u003ehttps://hzpt-inet-club.github.io/english-note/guide/grammar.html\u003c/a\u003e\u003c/p\u003e\u003c/blockquote\u003e\n\u003ch2 id=\"句子的组成部分\"\u003e句子的组成部分\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e主谓宾句型 -\u0026gt; I hit you\n\u003cul\u003e\n\u003cli\u003eI -\u0026gt; 主\u003c/li\u003e\n\u003cli\u003ehit -\u0026gt; 谓\u003c/li\u003e\n\u003cli\u003eyou -\u0026gt; 宾\n\u003cfigure\u003e\r\n    \u003cimg loading=\"lazy\" src=\"/images/%e8%8b%b1%e8%af%ad%e5%9f%ba%e7%a1%80%e8%af%ad%e6%b3%95.png\" width=\"350\"/\u003e \r\n\u003c/figure\u003e\r\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"十大词性\"\u003e十大词性\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003e单词是句子的最小组成部分，每个单词都有词性\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e\r\n\u003cdiv class=\"post-img-view\"\u003e\r\n    \u003ca data-fancybox=\"gallery\" href=\"/images/%e8%8b%b1%e8%af%ad%e5%9f%ba%e7%a1%80%e8%af%ad%e6%b3%95-1.png\"\u003e\r\n        \u003cimg src=\"/images/%e8%8b%b1%e8%af%ad%e5%9f%ba%e7%a1%80%e8%af%ad%e6%b3%95-1.png\" alt=\"\"  /\u003e\r\n    \u003c/a\u003e\r\n\u003c/div\u003e\r\n\r\n\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e代词pron.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003ccode\u003e指代某个名词的词\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e\r\n\u003cdiv class=\"post-img-view\"\u003e\r\n    \u003ca data-fancybox=\"gallery\" href=\"/images/%e8%8b%b1%e8%af%ad%e5%9f%ba%e7%a1%80%e8%af%ad%e6%b3%95-2.png\"\u003e\r\n        \u003cimg src=\"/images/%e8%8b%b1%e8%af%ad%e5%9f%ba%e7%a1%80%e8%af%ad%e6%b3%95-2.png\" alt=\"\"  /\u003e\r\n    \u003c/a\u003e\r\n\u003c/div\u003e\r\n\r\n\u003c/p\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e数词num.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003ccode\u003e跟数字有关的词\u003c/code\u003e\u003c/p\u003e","title":"浅尝英语语法--001 词性"},{"content":"\r","permalink":"http://localhost:1313/about/","summary":"about","title":"About"}]
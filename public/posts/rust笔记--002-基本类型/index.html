<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Rust笔记--002 基本类型 | liu'log</title>
<meta name=keywords content="rust"><meta name=description content="
学习参考：https://course.rs/basic/base-type/index.html
1. 数值类型
整数类型
Rust的内置数据类型

  
      
          长度
          有符号
          无符号
      
  
  
      
          8位
          i8
          u8
      
      
          16位
          i16
          u16
      
      
          32位
          i32
          u32
      
      
          64位
          i64
          u64
      
      
          128位
          i128
          u128
      
      
          视架构而定
          isize
          usize
      
  


有符号类型范围：-( 2n-1) ~ 2n - 1 - 1
无符号类型范围：0 ~ 2n-1
isize/usize取决于CPU类型：若CPU是32位的，他俩就是32位的
isize/usize主要应用：用作集合的索引
rust整型默认使用i32

let i = 1 // i是i32类型
数值字面量可以用以下形式书写"><meta name=author content="liuzifeng"><link rel=canonical href=http://localhost:1313/posts/rust%E7%AC%94%E8%AE%B0--002-%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.9de45e225101e4f99701d2b68fc6b8a1ef6027928be6391fa15bf7f56326c909.css integrity="sha256-neReIlEB5PmXAdK2j8a4oe9gJ5KL5jkfoVv39WMmyQk=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/icon.png><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/icon.png><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/icon.png><link rel=apple-touch-icon href=http://localhost:1313/icon.png><link rel=mask-icon href=http://localhost:1313/icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/posts/rust%E7%AC%94%E8%AE%B0--002-%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script src=https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js></script><link rel=stylesheet href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css><script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js></script><meta property="og:url" content="http://localhost:1313/posts/rust%E7%AC%94%E8%AE%B0--002-%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/"><meta property="og:site_name" content="liu'log"><meta property="og:title" content="Rust笔记--002 基本类型"><meta property="og:description" content=" 学习参考：https://course.rs/basic/base-type/index.html
1. 数值类型 整数类型 Rust的内置数据类型
长度 有符号 无符号 8位 i8 u8 16位 i16 u16 32位 i32 u32 64位 i64 u64 128位 i128 u128 视架构而定 isize usize 有符号类型范围：-( 2n-1) ~ 2n - 1 - 1 无符号类型范围：0 ~ 2n-1 isize/usize取决于CPU类型：若CPU是32位的，他俩就是32位的 isize/usize主要应用：用作集合的索引 rust整型默认使用i32 let i = 1 // i是i32类型 数值字面量可以用以下形式书写"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-05-31T17:57:22+08:00"><meta property="article:modified_time" content="2025-05-31T17:57:22+08:00"><meta property="article:tag" content="Rust"><meta property="og:image" content="http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Rust笔记--002 基本类型"><meta name=twitter:description content="
学习参考：https://course.rs/basic/base-type/index.html
1. 数值类型
整数类型
Rust的内置数据类型

  
      
          长度
          有符号
          无符号
      
  
  
      
          8位
          i8
          u8
      
      
          16位
          i16
          u16
      
      
          32位
          i32
          u32
      
      
          64位
          i64
          u64
      
      
          128位
          i128
          u128
      
      
          视架构而定
          isize
          usize
      
  


有符号类型范围：-( 2n-1) ~ 2n - 1 - 1
无符号类型范围：0 ~ 2n-1
isize/usize取决于CPU类型：若CPU是32位的，他俩就是32位的
isize/usize主要应用：用作集合的索引
rust整型默认使用i32

let i = 1 // i是i32类型
数值字面量可以用以下形式书写"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"Rust笔记--002 基本类型","item":"http://localhost:1313/posts/rust%E7%AC%94%E8%AE%B0--002-%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Rust笔记--002 基本类型","name":"Rust笔记--002 基本类型","description":" 学习参考：https://course.rs/basic/base-type/index.html\n1. 数值类型 整数类型 Rust的内置数据类型\n长度 有符号 无符号 8位 i8 u8 16位 i16 u16 32位 i32 u32 64位 i64 u64 128位 i128 u128 视架构而定 isize usize 有符号类型范围：-( 2n-1) ~ 2n - 1 - 1 无符号类型范围：0 ~ 2n-1 isize/usize取决于CPU类型：若CPU是32位的，他俩就是32位的 isize/usize主要应用：用作集合的索引 rust整型默认使用i32 let i = 1 // i是i32类型 数值字面量可以用以下形式书写\n","keywords":["rust"],"articleBody":" 学习参考：https://course.rs/basic/base-type/index.html\n1. 数值类型 整数类型 Rust的内置数据类型\n长度 有符号 无符号 8位 i8 u8 16位 i16 u16 32位 i32 u32 64位 i64 u64 128位 i128 u128 视架构而定 isize usize 有符号类型范围：-( 2n-1) ~ 2n - 1 - 1 无符号类型范围：0 ~ 2n-1 isize/usize取决于CPU类型：若CPU是32位的，他俩就是32位的 isize/usize主要应用：用作集合的索引 rust整型默认使用i32 let i = 1 // i是i32类型 数值字面量可以用以下形式书写\n数字字面量 示例 十进制 98_222 十六进制 0xff 八进制 0o77 二进制 0b1111_0000 字节(仅限于u8) b’A' 整数溢出 debug模式编译时，rust会检查整型溢出，存在问题则panic 使用--release参数编译时，rust不检查溢出，检测到溢出时按照补码循环溢出的规则处理\n大于该类型最大值的数值会被补码转换成能够支持的对应数字的最小值 let a : u8 = 255; let b = a.wrapping_add(20); // 溢出-\u003e补码 println!(\"{}\", b); // 19 显示处理可能的溢出，可以使用标准库针对原始数字类型提供的方法：\n使用wrapping_*方法在所有模式下都按照补码循环溢出规则处理 使用checked_*方法时发生溢出，则返回None值 使用overflowing_*方法返回该值和一个是否存在溢出的布尔值 使用saturating_*方法，可以限定计算后的结果不超过目标类型的最大值或低于最小值 assert_eq!(u8::MAX.saturating_add(127), u8::MAX); 浮点类型 f32和f64，默认为f64 f32类型是单精度浮点型，f64为双精度\n浮点数陷阱：\n浮点数往往是数字的近似表达 浮点数不一定可以比较，例如：HashMap类型存放的key必须实现std::cmp::Eq特征，而f64只实现了std::cmp::PartialEq特征 为了避免以上陷阱，需要遵守以下规则：\n避免在浮点数上测试相等性 当结果在数学上可能存在未定义时，需要格外的小心 assert!(0.1 + 0.2 == 0.3); // 会panic NaN 对于数学上未定义的记过，使用NaN(not a number)来处理，且NaN不能被比较\nlet x = (-42.0_f32).sqrt(); // 对复数取平方根 if x.is_nan() { println!(\"未定义的数学行为\") } 数字运算 支持加/减/乘/除/取模\n// 编译器会进行自动推导，给予twenty i32的类型 let twenty = 20; // 类型标注 let twenty_one: i32 = 21; // 通过类型后缀的方式进行类型标注：22是i32类型 let twenty_two = 22i32; // 只有同样类型，才能运算 let addition = twenty + twenty_one + twenty_two; println!(\"{} + {} + {} = {}\", twenty, twenty_one, twenty_two, addition); // 对于较长的数字，可以用_进行分割，提升可读性 let one_million: i64 = 1_000_000; println!(\"{}\", one_million.pow(2)); // 定义一个f32数组，其中42.0会自动被推导为f32类型 let forty_twos = [ 42.0, 42f32, 42.0_f32, ]; // 打印数组中第一个值，并控制小数位为2位 println!(\"{:.2}\", forty_twos[0]); 位运算 运算符 说明 \u0026 位与 相同位置均为1时则为1，否则为0 | 位或 相同位置只要有1时则为1，否则为0 ^ 异或 相同位置不相同则为1，相同则为0 ! 位非 把位中的0和1相互取反，即0置为1，1置为0 « 左移 所有位向左移动指定位数，右位补0 » 右移 所有位向右移动指定位数，带符号移动（正数补0，负数补1） 序列(Range) 只支持数字或字符类型\n// 1..5 生成从1到4的连续数字 for i in 1..5 { println!(\"{}\",i); } // 1..=5 生成从1到5的连续数字，包含5 for i in 1..=5 { println!(\"{}\",i); } // 'a'..='z' 生成从a到z的连续字符，包含z for i in 'a'..='z' { println!(\"{}\",i); } 使用As完成类型转换 As可以将一个类型转换成另一个类型，也可以实现诸如将指针转换为地址、地址转换为指针以及将指针转换为其他指针的操作\n有理数和复数 标准库不包含，使用num库\n按照以下步骤来引入 num 库：\n创建新工程 cargo new complex-num \u0026\u0026 cd complex-num 在 Cargo.toml 中的 [dependencies] 下添加一行 num = \"0.4.0\" 将 src/main.rs 文件中的 main 函数替换为下面的代码 运行 cargo run use num::complex::Complex; fn main() { let a = Complex { re: 2.1, im: -1.2 }; let b = Complex::new(11.1, 22.2); let result = a + b; println!(\"{} + {}i\", result.re, result.im) } 2. 字符·布尔·单元类型 字符类型(char) 不仅仅是ASCII，还包含所有的Unicode 字符类型占用4个字节\nlet x = '中'; println!(\"{}\",std::mem::size_of_val(\u0026x)); // 4 布尔(bool) true和false，占用1个字节\n单元类型 单元类型是() main函数和println!函数的返回值就是单元类型() 可以用()作为map的值，表示不关注value只关注key，不占用任何内存\n补充：无返回值的函数叫发散函数，main函数是有返回值的\n3. 语句和表达式 语句 执行一些操作但不会返回一个值\nlet a = 8; let b: Vec = Vec::new(); let (a, c) = (\"hi\", false); 以上都是语句，完成了一个具体的操作，但没有返回值\n表达式 执行一些操作后返回一个值 表达式不能包含分号! 表达式可以成为语句的一部分\nlet y = 6; // 6是表达式，返回一个6 调用一个函数/宏是表达式，用花括号包裹最终返回一个值的语句块也是表达式，因为他们都会返回一个值\nlet y = { let x = 3; // 语句 x + 1 // 表达式 }; fn ret_unit_type() { let x = 1; // if 语句块也是一个表达式，因此可以用于赋值，也可以直接返回 // 类似三元运算符，在Rust里我们可以这样写 let y = if x % 2 == 1 { \"odd\" } else { \"even\" }; // 或者写成一行 let z = if x % 2 == 1 { \"odd\" } else { \"even\" }; } 表达式如果不返回任何值，会隐式返回一个()\nassert_eq!(ret_unit_type(), ()) 4. 函数 函数构成 ![[Pasted image 20250215222747.png]]\n函数要点 函数名和变量名使用蛇形命名法，例如 fn add_two() -\u003e {} 函数位置可以随便放，只要有定义就行 每个函数的参数都需要标注类型 fn main() { another_function(5, 6.1); } fn another_function(x: i32, y: f32) { println!(\"The value of x is: {}\", x); println!(\"The value of y is: {}\", y); } 函数返回 函数返回值就是函数体最后一条表达式的返回值，也可以使用return提前返回\nfn plus_or_minus(x:i32) -\u003e i32 { if x \u003e 5 { return x - 5 // return提前返回 } x + 5 // 表达式作为返回值 } 无返回值，返回单元类型()\n函数没有返回值，返回一个() 通过;结尾的语句返回一个() use std::fmt::Debug; fn report(item: T) { println!(\"{:?}\", item); // 隐式返回() } fn clear(text: \u0026mut String) -\u003e () { // 显式返回() *text = String::from(\"\"); } 永不返回的发散函数，返回 !\n往往用作导致程序崩溃的函数 fn dead_end() -\u003e ! { panic!(\"你已经到了穷途末路，崩溃吧！\"); } 下面的函数创建了一个无限循环，该循环永不跳出，因此函数也永不返回： fn forever() -\u003e ! { loop { //... }; } ","wordCount":"2335","inLanguage":"en","image":"http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2025-05-31T17:57:22+08:00","dateModified":"2025-05-31T17:57:22+08:00","author":{"@type":"Person","name":"liuzifeng"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/posts/rust%E7%AC%94%E8%AE%B0--002-%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/"},"publisher":{"@type":"Organization","name":"liu'log","logo":{"@type":"ImageObject","url":"http://localhost:1313/icon.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="liu'log (Alt + H)"><img src=http://localhost:1313/apple-touch-icon.png alt aria-label=logo height=35>liu'log</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/ title=Home><span>Home</span></a></li><li><a href=http://localhost:1313/archives/ title=Archives><span>Archives</span></a></li><li><a href=http://localhost:1313/tags/ title=Tags><span>Tags</span></a></li><li><a href=http://localhost:1313/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=http://localhost:1313/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:1313/>Home</a>&nbsp;»&nbsp;<a href=http://localhost:1313/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Rust笔记--002 基本类型</h1><div class=post-meta><span title='2025-05-31 17:57:22 +0800 CST'>May 31, 2025</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;2335 words&nbsp;·&nbsp;liuzifeng</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#1-数值类型>1. 数值类型</a><ul><li><a href=#整数类型>整数类型</a></li><li><a href=#整数溢出>整数溢出</a></li><li><a href=#浮点类型>浮点类型</a></li><li><a href=#nan>NaN</a></li><li><a href=#数字运算>数字运算</a></li><li><a href=#位运算>位运算</a></li><li><a href=#序列range>序列(Range)</a></li><li><a href=#使用as完成类型转换>使用As完成类型转换</a></li><li><a href=#有理数和复数>有理数和复数</a></li></ul></li><li><a href=#2-字符布尔单元类型>2. 字符·布尔·单元类型</a><ul><li><a href=#字符类型char>字符类型(char)</a></li><li><a href=#布尔bool>布尔(bool)</a></li><li><a href=#单元类型>单元类型</a></li></ul></li><li><a href=#3-语句和表达式>3. 语句和表达式</a><ul><li><a href=#语句>语句</a></li><li><a href=#表达式>表达式</a></li></ul></li><li><a href=#4-函数>4. 函数</a><ul><li><a href=#函数构成>函数构成</a></li><li><a href=#函数要点>函数要点</a></li><li><a href=#函数返回>函数返回</a></li></ul></li></ul></nav></div></details></div><div class=post-content><blockquote><p>学习参考：<a href=https://course.rs/basic/base-type/index.html>https://course.rs/basic/base-type/index.html</a></p></blockquote><h2 id=1-数值类型>1. 数值类型<a hidden class=anchor aria-hidden=true href=#1-数值类型>#</a></h2><h3 id=整数类型>整数类型<a hidden class=anchor aria-hidden=true href=#整数类型>#</a></h3><p><code>Rust的内置数据类型</code></p><table><thead><tr><th>长度</th><th>有符号</th><th>无符号</th></tr></thead><tbody><tr><td>8位</td><td>i8</td><td>u8</td></tr><tr><td>16位</td><td>i16</td><td>u16</td></tr><tr><td>32位</td><td>i32</td><td>u32</td></tr><tr><td>64位</td><td>i64</td><td>u64</td></tr><tr><td>128位</td><td>i128</td><td>u128</td></tr><tr><td>视架构而定</td><td>isize</td><td>usize</td></tr></tbody></table><ul><li>有符号类型范围：-( 2n-1) ~ 2n - 1 - 1</li><li>无符号类型范围：0 ~ 2n-1</li><li>isize/usize取决于CPU类型：若CPU是32位的，他俩就是32位的</li><li>isize/usize主要应用：用作集合的索引</li><li>rust整型默认使用i32</li></ul><pre tabindex=0><code>let i = 1 // i是i32类型
</code></pre><p><code>数值字面量可以用以下形式书写</code></p><table><thead><tr><th>数字字面量</th><th>示例</th></tr></thead><tbody><tr><td>十进制</td><td>98_222</td></tr><tr><td>十六进制</td><td>0xff</td></tr><tr><td>八进制</td><td>0o77</td></tr><tr><td>二进制</td><td>0b1111_0000</td></tr><tr><td>字节(仅限于u8)</td><td>b&rsquo;A'</td></tr></tbody></table><h3 id=整数溢出>整数溢出<a hidden class=anchor aria-hidden=true href=#整数溢出>#</a></h3><p><code>debug模式编译时，rust会检查整型溢出，存在问题则panic</code>
<code>使用--release参数编译时，rust不检查溢出，检测到溢出时按照补码循环溢出的规则处理</code></p><ul><li>大于该类型最大值的数值会被补码转换成能够支持的对应数字的最小值</li></ul><pre tabindex=0><code>let a : u8 = 255;
let b = a.wrapping_add(20); // 溢出-&gt;补码
println!(&#34;{}&#34;, b); // 19
</code></pre><p>显示处理可能的溢出，可以使用标准库针对原始数字类型提供的方法：</p><ul><li>使用<code>wrapping_*</code>方法<strong>在所有模式下</strong>都按照补码循环溢出规则处理</li><li>使用<code>checked_*</code>方法时发生溢出，则返回<code>None</code>值</li><li>使用<code>overflowing_*</code>方法返回该值和一个是否存在溢出的布尔值</li><li>使用<code>saturating_*</code>方法，可以限定计算后的结果不超过目标类型的最大值或低于最小值</li></ul><pre tabindex=0><code>assert_eq!(u8::MAX.saturating_add(127), u8::MAX);
</code></pre><h3 id=浮点类型>浮点类型<a hidden class=anchor aria-hidden=true href=#浮点类型>#</a></h3><p><code>f32和f64，默认为f64</code>
<code>f32类型是单精度浮点型，f64为双精度</code></p><p>浮点数陷阱：</p><ul><li><strong>浮点数往往是数字的近似表达</strong></li><li><strong>浮点数不一定可以比较</strong>，例如：HashMap类型存放的key必须实现std::cmp::Eq特征，而f64只实现了std::cmp::PartialEq特征</li></ul><p>为了避免以上陷阱，需要遵守以下规则：</p><ul><li>避免在浮点数上测试相等性</li><li>当结果在数学上可能存在未定义时，需要格外的小心</li></ul><pre tabindex=0><code>assert!(0.1 + 0.2 == 0.3); // 会panic
</code></pre><h3 id=nan>NaN<a hidden class=anchor aria-hidden=true href=#nan>#</a></h3><p><code>对于数学上未定义的记过，使用NaN(not a number)来处理，且NaN不能被比较</code></p><pre tabindex=0><code>let x = (-42.0_f32).sqrt();  // 对复数取平方根
if x.is_nan() { 
	println!(&#34;未定义的数学行为&#34;) 
}
</code></pre><h3 id=数字运算>数字运算<a hidden class=anchor aria-hidden=true href=#数字运算>#</a></h3><p><code>支持加/减/乘/除/取模</code></p><pre tabindex=0><code>// 编译器会进行自动推导，给予twenty i32的类型
let twenty = 20; 
// 类型标注 
let twenty_one: i32 = 21; 
// 通过类型后缀的方式进行类型标注：22是i32类型 
let twenty_two = 22i32; 
// 只有同样类型，才能运算 
let addition = twenty + twenty_one + twenty_two; 
println!(&#34;{} + {} + {} = {}&#34;, twenty, twenty_one, twenty_two, addition); 
// 对于较长的数字，可以用_进行分割，提升可读性 
let one_million: i64 = 1_000_000; 
println!(&#34;{}&#34;, one_million.pow(2)); 
// 定义一个f32数组，其中42.0会自动被推导为f32类型 
let forty_twos = [ 
	42.0,
	42f32, 
	42.0_f32, 
]; 
// 打印数组中第一个值，并控制小数位为2位 
println!(&#34;{:.2}&#34;, forty_twos[0]);
</code></pre><h3 id=位运算>位运算<a hidden class=anchor aria-hidden=true href=#位运算>#</a></h3><table><thead><tr><th>运算符</th><th>说明</th></tr></thead><tbody><tr><td>& 位与</td><td>相同位置均为1时则为1，否则为0</td></tr><tr><td>| 位或</td><td>相同位置只要有1时则为1，否则为0</td></tr><tr><td>^ 异或</td><td>相同位置不相同则为1，相同则为0</td></tr><tr><td>! 位非</td><td>把位中的0和1相互取反，即0置为1，1置为0</td></tr><tr><td>&#171; 左移</td><td>所有位向左移动指定位数，右位补0</td></tr><tr><td>&#187; 右移</td><td>所有位向右移动指定位数，带符号移动（正数补0，负数补1）</td></tr></tbody></table><h3 id=序列range>序列(Range)<a hidden class=anchor aria-hidden=true href=#序列range>#</a></h3><p><code>只支持数字或字符类型</code></p><pre tabindex=0><code>// 1..5 生成从1到4的连续数字
for i in 1..5 { 
	println!(&#34;{}&#34;,i); 
}

// 1..=5 生成从1到5的连续数字，包含5
for i in 1..=5 { 
	println!(&#34;{}&#34;,i); 
}

// &#39;a&#39;..=&#39;z&#39; 生成从a到z的连续字符，包含z
for i in &#39;a&#39;..=&#39;z&#39; {
    println!(&#34;{}&#34;,i);
}
</code></pre><h3 id=使用as完成类型转换>使用As完成类型转换<a hidden class=anchor aria-hidden=true href=#使用as完成类型转换>#</a></h3><p><code>As可以将一个类型转换成另一个类型，也可以实现诸如将指针转换为地址、地址转换为指针以及将指针转换为其他指针的操作</code></p><h3 id=有理数和复数>有理数和复数<a hidden class=anchor aria-hidden=true href=#有理数和复数>#</a></h3><p><code>标准库不包含，使用num库</code></p><p>按照以下步骤来引入 <code>num</code> 库：</p><ol><li>创建新工程 <code>cargo new complex-num && cd complex-num</code></li><li>在 <code>Cargo.toml</code> 中的 <code>[dependencies]</code> 下添加一行 <code>num = "0.4.0"</code></li><li>将 <code>src/main.rs</code> 文件中的 <code>main</code> 函数替换为下面的代码</li><li>运行 <code>cargo run</code></li></ol><pre tabindex=0><code>use num::complex::Complex;

 fn main() {
   let a = Complex { re: 2.1, im: -1.2 };
   let b = Complex::new(11.1, 22.2);
   let result = a + b;

   println!(&#34;{} + {}i&#34;, result.re, result.im)
 }
</code></pre><h2 id=2-字符布尔单元类型>2. 字符·布尔·单元类型<a hidden class=anchor aria-hidden=true href=#2-字符布尔单元类型>#</a></h2><h3 id=字符类型char>字符类型(char)<a hidden class=anchor aria-hidden=true href=#字符类型char>#</a></h3><p><code>不仅仅是ASCII，还包含所有的Unicode</code>
<code>字符类型占用4个字节</code></p><pre tabindex=0><code>let x = &#39;中&#39;; 
println!(&#34;{}&#34;,std::mem::size_of_val(&amp;x));  // 4
</code></pre><h3 id=布尔bool>布尔(bool)<a hidden class=anchor aria-hidden=true href=#布尔bool>#</a></h3><p><code>true和false，占用1个字节</code></p><h3 id=单元类型>单元类型<a hidden class=anchor aria-hidden=true href=#单元类型>#</a></h3><p><code>单元类型是()</code>
<code>main函数和println!函数的返回值就是单元类型()</code>
<code>可以用()作为map的值，表示不关注value只关注key，不占用任何内存</code></p><p>补充：无返回值的函数叫<strong>发散函数</strong>，main函数是有返回值的</p><h2 id=3-语句和表达式>3. 语句和表达式<a hidden class=anchor aria-hidden=true href=#3-语句和表达式>#</a></h2><h3 id=语句>语句<a hidden class=anchor aria-hidden=true href=#语句>#</a></h3><p><code>执行一些操作但不会返回一个值</code></p><pre tabindex=0><code>let a = 8;
let b: Vec&lt;f64&gt; = Vec::new();
let (a, c) = (&#34;hi&#34;, false);
</code></pre><p>以上都是语句，完成了一个具体的操作，但没有返回值</p><h3 id=表达式>表达式<a hidden class=anchor aria-hidden=true href=#表达式>#</a></h3><p><code>执行一些操作后返回一个值</code>
<code>表达式不能包含分号!</code>
<code>表达式可以成为语句的一部分</code></p><pre tabindex=0><code>let y = 6;  // 6是表达式，返回一个6
</code></pre><p><code>调用一个函数/宏是表达式，用花括号包裹最终返回一个值的语句块也是表达式，因为他们都会返回一个值</code></p><pre tabindex=0><code>let y = {
    let x = 3;  // 语句
    x + 1  // 表达式
};

fn ret_unit_type() {
    let x = 1;
    // if 语句块也是一个表达式，因此可以用于赋值，也可以直接返回
    // 类似三元运算符，在Rust里我们可以这样写
    let y = if x % 2 == 1 {
        &#34;odd&#34;
    } else {
        &#34;even&#34;
    };
    // 或者写成一行
    let z = if x % 2 == 1 { &#34;odd&#34; } else { &#34;even&#34; };
}
</code></pre><p><code>表达式如果不返回任何值，会隐式返回一个()</code></p><pre tabindex=0><code>assert_eq!(ret_unit_type(), ())
</code></pre><h2 id=4-函数>4. 函数<a hidden class=anchor aria-hidden=true href=#4-函数>#</a></h2><h3 id=函数构成>函数构成<a hidden class=anchor aria-hidden=true href=#函数构成>#</a></h3><p>![[Pasted image 20250215222747.png]]</p><h3 id=函数要点>函数要点<a hidden class=anchor aria-hidden=true href=#函数要点>#</a></h3><ul><li>函数名和变量名使用蛇形命名法，例如 fn add_two() -> {}</li><li>函数位置可以随便放，只要有定义就行</li><li>每个函数的参数都需要标注类型</li></ul><pre tabindex=0><code>fn main() {
    another_function(5, 6.1);
}

fn another_function(x: i32, y: f32) {
    println!(&#34;The value of x is: {}&#34;, x);
    println!(&#34;The value of y is: {}&#34;, y);
}
</code></pre><h3 id=函数返回>函数返回<a hidden class=anchor aria-hidden=true href=#函数返回>#</a></h3><p><code>函数返回值就是函数体最后一条表达式的返回值，也可以使用return提前返回</code></p><pre tabindex=0><code>fn plus_or_minus(x:i32) -&gt; i32 {
    if x &gt; 5 {
        return x - 5  // return提前返回
    }

    x + 5  // 表达式作为返回值
}
</code></pre><p>无返回值，返回单元类型()</p><ul><li>函数没有返回值，返回一个()</li><li>通过;结尾的语句返回一个()</li></ul><pre tabindex=0><code>use std::fmt::Debug;

fn report&lt;T: Debug&gt;(item: T) {
  println!(&#34;{:?}&#34;, item);  // 隐式返回()
}

fn clear(text: &amp;mut String) -&gt; () {   // 显式返回()
  *text = String::from(&#34;&#34;);
}
</code></pre><p>永不返回的发散函数，返回 !</p><ul><li>往往用作导致程序崩溃的函数</li></ul><pre tabindex=0><code>fn dead_end() -&gt; ! {
  panic!(&#34;你已经到了穷途末路，崩溃吧！&#34;);
}
</code></pre><ul><li>下面的函数创建了一个无限循环，该循环永不跳出，因此函数也永不返回：</li></ul><pre tabindex=0><code>fn forever() -&gt; ! {
  loop {
    //...
  };
}
</code></pre></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:1313/tags/rust/>Rust</a></li></ul><nav class=paginav><a class=prev href=http://localhost:1313/posts/rust%E7%AC%94%E8%AE%B0--003-%E6%89%80%E6%9C%89%E6%9D%83/><span class=title>« Prev</span><br><span>Rust笔记--003 所有权</span>
</a><a class=next href=http://localhost:1313/posts/rust%E7%AC%94%E8%AE%B0--001-%E5%8F%98%E9%87%8F/><span class=title>Next »</span><br><span>Rust笔记--001 变量</span></a></nav></footer><div id=tw-comment></div><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="light"?"light":"dark",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const s={src:"https://giscus.app/client.js","data-repo":"StephenLiu2/liu-log","data-repo-id":"R_kgDONwIeSw","data-category":"Announcements","data-category-id":"DIC_kwDONwIeS84CqBH_","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"zh-CN","data-loading":"lazy",crossorigin:"anonymous"},e=document.createElement("script");Object.entries(s).forEach(([t,n])=>e.setAttribute(t,n)),document.querySelector("#tw-comment").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme);const n=document.querySelector("#theme-toggle-float");n&&n.addEventListener("click",setGiscusTheme)})</script></article></main><footer class=footer><span>&copy; 2025 <a href=http://localhost:1313/>liu'log</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>
<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Rust笔记--003 所有权 | liu'log</title>
<meta name=keywords content="rust"><meta name=description content="
学习参考：https://course.rs/basic/ownership/ownership.html
所有权原则

Rust中每一个值都被一个变量所拥有，该变量称为值的所有者
一个值同时只能被一个变量所拥有
当所有者（变量）离开作用域范围时，这个值将被丢弃

变量绑定背后的数据交互
part1：未被转移所有权
let x = 5;
let y = x;
执行逻辑：
代码首先将5绑定到变量x，接着拷贝x的值赋给y，最终x和y都等于5"><meta name=author content="liuzifeng"><link rel=canonical href=http://localhost:1313/posts/rust%E7%AC%94%E8%AE%B0--003-%E6%89%80%E6%9C%89%E6%9D%83/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.9de45e225101e4f99701d2b68fc6b8a1ef6027928be6391fa15bf7f56326c909.css integrity="sha256-neReIlEB5PmXAdK2j8a4oe9gJ5KL5jkfoVv39WMmyQk=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/icon.png><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/icon.png><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/icon.png><link rel=apple-touch-icon href=http://localhost:1313/icon.png><link rel=mask-icon href=http://localhost:1313/icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/posts/rust%E7%AC%94%E8%AE%B0--003-%E6%89%80%E6%9C%89%E6%9D%83/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script src=https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js></script><link rel=stylesheet href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css><script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js></script><meta property="og:url" content="http://localhost:1313/posts/rust%E7%AC%94%E8%AE%B0--003-%E6%89%80%E6%9C%89%E6%9D%83/"><meta property="og:site_name" content="liu'log"><meta property="og:title" content="Rust笔记--003 所有权"><meta property="og:description" content=" 学习参考：https://course.rs/basic/ownership/ownership.html
所有权原则 Rust中每一个值都被一个变量所拥有，该变量称为值的所有者 一个值同时只能被一个变量所拥有 当所有者（变量）离开作用域范围时，这个值将被丢弃 变量绑定背后的数据交互 part1：未被转移所有权 let x = 5; let y = x; 执行逻辑： 代码首先将5绑定到变量x，接着拷贝x的值赋给y，最终x和y都等于5"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-05-31T19:03:07+08:00"><meta property="article:modified_time" content="2025-05-31T19:03:07+08:00"><meta property="article:tag" content="Rust"><meta property="og:image" content="http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Rust笔记--003 所有权"><meta name=twitter:description content="
学习参考：https://course.rs/basic/ownership/ownership.html
所有权原则

Rust中每一个值都被一个变量所拥有，该变量称为值的所有者
一个值同时只能被一个变量所拥有
当所有者（变量）离开作用域范围时，这个值将被丢弃

变量绑定背后的数据交互
part1：未被转移所有权
let x = 5;
let y = x;
执行逻辑：
代码首先将5绑定到变量x，接着拷贝x的值赋给y，最终x和y都等于5"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"Rust笔记--003 所有权","item":"http://localhost:1313/posts/rust%E7%AC%94%E8%AE%B0--003-%E6%89%80%E6%9C%89%E6%9D%83/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Rust笔记--003 所有权","name":"Rust笔记--003 所有权","description":" 学习参考：https://course.rs/basic/ownership/ownership.html\n所有权原则 Rust中每一个值都被一个变量所拥有，该变量称为值的所有者 一个值同时只能被一个变量所拥有 当所有者（变量）离开作用域范围时，这个值将被丢弃 变量绑定背后的数据交互 part1：未被转移所有权 let x = 5; let y = x; 执行逻辑： 代码首先将5绑定到变量x，接着拷贝x的值赋给y，最终x和y都等于5\n","keywords":["rust"],"articleBody":" 学习参考：https://course.rs/basic/ownership/ownership.html\n所有权原则 Rust中每一个值都被一个变量所拥有，该变量称为值的所有者 一个值同时只能被一个变量所拥有 当所有者（变量）离开作用域范围时，这个值将被丢弃 变量绑定背后的数据交互 part1：未被转移所有权 let x = 5; let y = x; 执行逻辑： 代码首先将5绑定到变量x，接着拷贝x的值赋给y，最终x和y都等于5\n剖析： 整数是 Rust 基本数据类型，是固定大小的简单值，因此这两个值都是通过自动拷贝的方式来赋值的，都被存在栈中，完全无需在堆上分配内存。故不需要所有权转移。\npart2：转移所有权 let s1 = String::from(\"hello\"); let s2 = s1; 浅谈String： String是一个复杂类型，由存储在栈中的堆指针、字符串长度、字符串容量共同组成。 其中堆指针指向了真实存储字符串内容的堆内存。\n执行逻辑： 将s1指向存储字符串堆内容的指针移动给s2，s1不指向任何数据。即将s1对字符串的所有权转移给s2\n剖析：\n如果拷贝String和存储在堆上的字节数组(深拷贝)给s2，会对性能造成非常大的影响。 如果只拷贝String本身非常快，因为在64位机器上就拷贝了8字节的指针，8字节的长度，8字节的容量，总计24字节。但是这样s1和s2会同时指向一个字节数组，即一个值有两个所有者。 假设一个值可以拥有两个所有者，当变量离开作用域时，Rust会自动调用drop函数清理变量的堆内存，由于两个变量指向了同一个位置，当s1和s2离开作用域时，它们都会尝试释放相同的内存，即二次释放。 故Rust采用类似浅拷贝的方式，同时使s1无效，这个操作被称为移动 注意： s1的所有权被转移给s2后，s1无效，这时如果使用s1会发生错误。\nlet s1 = String::from(\"hello\"); let s2 = s1; println!(\"{}, world!\", s1); // Error part3：引用 let x: \u0026str = \"hello, world\"; let y = x; println!(\"{},{}\",x,y); 浅析\u0026str： 这是字符串字面量的类型，被硬编码到程序中的字符串值。\n执行过程： x引用了存储在二进制可执行文件中的字符串，并没有持有所有权。故let y = x仅仅对该引用进行了拷贝，此时y和x都引用了同一个字符串。\n和part2的区别： String的例子中s1持有了通过String::from函数创建的值的所有权，在这个例子中，x只是引用了存储在二进制可执行文件中的字符串，并没有持有所有权。\npart4：克隆(深拷贝) let s1 = String::from(\"hello\"); let s2 = s1.clone(); println!(\"s1 = {}, s2 = {}\", s1, s2); // Success 注意：Rust永远不会自动创建数据的深拷贝\n执行过程： 使用clone函数，s2完整复制了s1的数据。没有发生所有权转移。\n可以自动拷贝的类型 如果一个类型拥有Copy特征，一个旧的变量在被赋值给其他变量后仍然可用，也就是赋值的过程即是拷贝的过程\n所有整数类型，比如 u32 布尔类型，bool，它的值是 true 和 false 所有浮点数类型，比如 f64 字符类型，char 元组，当且仅当其包含的类型也都是 Copy 的时候。比如，(i32, i32) 是 Copy 的，但 (i32, String) 就不是 不可变引用 \u0026T 函数传值和返回 将值传递给函数，一样会发生 移动 或者 复制\nfn main() { let s = String::from(\"hello\"); // s 进入作用域 takes_ownership(s); // s 的值移动到函数里 ... // ... 所以到这里不再有效 let x = 5; // x 进入作用域 makes_copy(x); // x 应该移动函数里， // 但 i32 是 Copy 的，所以在后面可继续使用 x } // 这里, x 先移出了作用域，然后是 s。但因为 s 的值已被移走， // 所以不会有特殊操作 fn takes_ownership(some_string: String) { // some_string 进入作用域 println!(\"{}\", some_string); } // 这里，some_string 移出作用域并调用 `drop` 方法。占用的内存被释放 fn makes_copy(some_integer: i32) { // some_integer 进入作用域 println!(\"{}\", some_integer); } // 这里，some_integer 移出作用域。不会有特殊操作 同样的，函数返回值也有所有权\nfn main() { let s1 = gives_ownership(); // gives_ownership 将返回值 // 移给 s1 let s2 = String::from(\"hello\"); // s2 进入作用域 let s3 = takes_and_gives_back(s2); // s2 被移动到 // takes_and_gives_back 中, // 它也将返回值移给 s3 } // 这里, s3 移出作用域并被丢弃。s2 也移出作用域，但已被移走， // 所以什么也不会发生。s1 移出作用域并被丢弃 fn gives_ownership() -\u003e String { // gives_ownership 将返回值移动给 // 调用它的函数 let some_string = String::from(\"hello\"); // some_string 进入作用域. some_string // 返回 some_string 并移出给调用的函数 } // takes_and_gives_back 将传入字符串并返回该值 fn takes_and_gives_back(a_string: String) -\u003e String { // a_string 进入作用域 a_string // 返回 a_string 并移出给调用的函数 } ","wordCount":"1632","inLanguage":"en","image":"http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2025-05-31T19:03:07+08:00","dateModified":"2025-05-31T19:03:07+08:00","author":{"@type":"Person","name":"liuzifeng"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/posts/rust%E7%AC%94%E8%AE%B0--003-%E6%89%80%E6%9C%89%E6%9D%83/"},"publisher":{"@type":"Organization","name":"liu'log","logo":{"@type":"ImageObject","url":"http://localhost:1313/icon.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="liu'log (Alt + H)"><img src=http://localhost:1313/apple-touch-icon.png alt aria-label=logo height=35>liu'log</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/ title=Home><span>Home</span></a></li><li><a href=http://localhost:1313/archives/ title=Archives><span>Archives</span></a></li><li><a href=http://localhost:1313/tags/ title=Tags><span>Tags</span></a></li><li><a href=http://localhost:1313/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=http://localhost:1313/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:1313/>Home</a>&nbsp;»&nbsp;<a href=http://localhost:1313/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Rust笔记--003 所有权</h1><div class=post-meta><span title='2025-05-31 19:03:07 +0800 CST'>May 31, 2025</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;1632 words&nbsp;·&nbsp;liuzifeng</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#所有权原则>所有权原则</a></li><li><a href=#变量绑定背后的数据交互>变量绑定背后的数据交互</a><ul><li><a href=#part1未被转移所有权>part1：<code>未被转移所有权</code></a></li><li><a href=#part2转移所有权>part2：<code>转移所有权</code></a></li><li><a href=#part3引用>part3：<code>引用</code></a></li><li><a href=#part4克隆深拷贝>part4：<code>克隆(深拷贝)</code></a></li></ul></li><li><a href=#可以自动拷贝的类型>可以自动拷贝的类型</a></li><li><a href=#函数传值和返回>函数传值和返回</a></li></ul></nav></div></details></div><div class=post-content><blockquote><p>学习参考：<a href=https://course.rs/basic/ownership/ownership.html>https://course.rs/basic/ownership/ownership.html</a></p></blockquote><h2 id=所有权原则>所有权原则<a hidden class=anchor aria-hidden=true href=#所有权原则>#</a></h2><ol><li>Rust中每一个值都被一个变量所拥有，该变量称为值的所有者</li><li>一个值同时只能被一个变量所拥有</li><li>当所有者（变量）离开作用域范围时，这个值将被丢弃</li></ol><h2 id=变量绑定背后的数据交互>变量绑定背后的数据交互<a hidden class=anchor aria-hidden=true href=#变量绑定背后的数据交互>#</a></h2><h3 id=part1未被转移所有权>part1：<code>未被转移所有权</code><a hidden class=anchor aria-hidden=true href=#part1未被转移所有权>#</a></h3><pre tabindex=0><code>let x = 5;
let y = x;
</code></pre><p><strong>执行逻辑：</strong>
代码首先将<strong>5</strong>绑定到变量<strong>x</strong>，接着拷贝<strong>x</strong>的值赋给<strong>y</strong>，最终<strong>x</strong>和<strong>y</strong>都等于5</p><p><strong>剖析：</strong>
整数是 Rust 基本数据类型，是固定大小的简单值，因此这两个值都是通过<strong>自动拷贝</strong>的方式来赋值的，都被存在栈中，完全无需在堆上分配内存。故不需要所有权转移。</p><h3 id=part2转移所有权>part2：<code>转移所有权</code><a hidden class=anchor aria-hidden=true href=#part2转移所有权>#</a></h3><pre tabindex=0><code>let s1 = String::from(&#34;hello&#34;); 
let s2 = s1;
</code></pre><p><strong>浅谈String：</strong>
String是一个复杂类型，由存储在栈中的堆指针、字符串长度、字符串容量共同组成。
其中堆指针指向了真实存储字符串内容的堆内存。</p><p><strong>执行逻辑：</strong>
将s1指向存储字符串堆内容的指针移动给s2，s1不指向任何数据。即<strong>将s1对字符串的所有权转移给s2</strong></p><p><strong>剖析：</strong></p><ol><li>如果拷贝String和存储在堆上的字节数组(深拷贝)给s2，会对性能造成非常大的影响。</li><li>如果只拷贝String本身非常快，因为在64位机器上就拷贝了8字节的指针，8字节的长度，8字节的容量，总计24字节。但是这样s1和s2会同时指向一个字节数组，即一个值有两个所有者。</li><li>假设一个值可以拥有两个所有者，当变量离开作用域时，Rust会自动调用drop函数清理变量的堆内存，由于两个变量指向了同一个位置，当s1和s2离开作用域时，它们都会尝试释放相同的内存，即<strong>二次释放</strong>。</li><li>故Rust采用类似浅拷贝的方式，同时使s1无效，这个操作被称为<strong>移动</strong><div class=post-img-view><a data-fancybox=gallery href=/images/Rust%e7%ac%94%e8%ae%b0--003%20%e6%89%80%e6%9c%89%e6%9d%83.png><img src=/images/Rust%e7%ac%94%e8%ae%b0--003%20%e6%89%80%e6%9c%89%e6%9d%83.png alt></a></div></li></ol><p><strong>注意：</strong>
s1的所有权被转移给s2后，s1无效，这时如果使用s1会发生错误。</p><pre tabindex=0><code>let s1 = String::from(&#34;hello&#34;); 
let s2 = s1;
println!(&#34;{}, world!&#34;, s1);  // Error
</code></pre><h3 id=part3引用>part3：<code>引用</code><a hidden class=anchor aria-hidden=true href=#part3引用>#</a></h3><pre tabindex=0><code>let x: &amp;str = &#34;hello, world&#34;;
let y = x;
println!(&#34;{},{}&#34;,x,y);
</code></pre><p><strong>浅析&amp;str：</strong>
这是字符串字面量的类型，被硬编码到程序中的字符串值。</p><p><strong>执行过程：</strong>
x引用了存储在二进制可执行文件中的字符串，并没有持有所有权。故<code>let y = x</code>仅仅对该引用进行了拷贝，此时y和x都引用了同一个字符串。</p><p><strong>和part2的区别：</strong>
String的例子中s1持有了通过String::from函数创建的值的所有权，在这个例子中，x只是引用了存储在二进制可执行文件中的字符串，并没有持有所有权。</p><h3 id=part4克隆深拷贝>part4：<code>克隆(深拷贝)</code><a hidden class=anchor aria-hidden=true href=#part4克隆深拷贝>#</a></h3><pre tabindex=0><code>let s1 = String::from(&#34;hello&#34;); 
let s2 = s1.clone();
println!(&#34;s1 = {}, s2 = {}&#34;, s1, s2);  // Success
</code></pre><p><code>注意：Rust永远不会自动创建数据的深拷贝</code></p><p><strong>执行过程：</strong>
使用clone函数，s2完整复制了s1的数据。没有发生所有权转移。</p><h2 id=可以自动拷贝的类型>可以自动拷贝的类型<a hidden class=anchor aria-hidden=true href=#可以自动拷贝的类型>#</a></h2><p><code>如果一个类型拥有Copy特征，一个旧的变量在被赋值给其他变量后仍然可用，也就是赋值的过程即是拷贝的过程</code></p><ul><li>所有整数类型，比如 <code>u32</code></li><li>布尔类型，<code>bool</code>，它的值是 <code>true</code> 和 <code>false</code></li><li>所有浮点数类型，比如 <code>f64</code></li><li>字符类型，<code>char</code></li><li>元组，当且仅当其包含的类型也都是 <code>Copy</code> 的时候。比如，<code>(i32, i32)</code> 是 <code>Copy</code> 的，但 <code>(i32, String)</code> 就不是</li><li>不可变引用 <code>&amp;T</code> </li></ul><h2 id=函数传值和返回>函数传值和返回<a hidden class=anchor aria-hidden=true href=#函数传值和返回>#</a></h2><p>将值传递给函数，一样会发生 <code>移动</code> 或者 <code>复制</code></p><pre tabindex=0><code>fn main() {
	let s = String::from(&#34;hello&#34;);   // s 进入作用域 
	takes_ownership(s);              // s 的值移动到函数里 ... 
						             // ... 所以到这里不再有效 
	let x = 5;                       // x 进入作用域 
	makes_copy(x);                   // x 应该移动函数里， 
	                                 // 但 i32 是 Copy 的，所以在后面可继续使用 x
}  // 这里, x 先移出了作用域，然后是 s。但因为 s 的值已被移走， 
   // 所以不会有特殊操作 
   
fn takes_ownership(some_string: String) { // some_string 进入作用域 
	println!(&#34;{}&#34;, some_string);
} // 这里，some_string 移出作用域并调用 `drop` 方法。占用的内存被释放 

fn makes_copy(some_integer: i32) { // some_integer 进入作用域 
	println!(&#34;{}&#34;, some_integer); 
} // 这里，some_integer 移出作用域。不会有特殊操作
</code></pre><p>同样的，函数返回值也有所有权</p><pre tabindex=0><code>fn main() {
    let s1 = gives_ownership();         // gives_ownership 将返回值
                                        // 移给 s1

    let s2 = String::from(&#34;hello&#34;);     // s2 进入作用域

    let s3 = takes_and_gives_back(s2);  // s2 被移动到
                                        // takes_and_gives_back 中,
                                        // 它也将返回值移给 s3
} // 这里, s3 移出作用域并被丢弃。s2 也移出作用域，但已被移走，
  // 所以什么也不会发生。s1 移出作用域并被丢弃

fn gives_ownership() -&gt; String {             // gives_ownership 将返回值移动给
                                             // 调用它的函数

    let some_string = String::from(&#34;hello&#34;); // some_string 进入作用域.

    some_string                              // 返回 some_string 并移出给调用的函数
}

// takes_and_gives_back 将传入字符串并返回该值
fn takes_and_gives_back(a_string: String) -&gt; String { // a_string 进入作用域

    a_string  // 返回 a_string 并移出给调用的函数
}
</code></pre></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:1313/tags/rust/>Rust</a></li></ul><nav class=paginav><a class=next href=http://localhost:1313/posts/rust%E7%AC%94%E8%AE%B0--002-%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/><span class=title>Next »</span><br><span>Rust笔记--002 基本类型</span></a></nav></footer><div id=tw-comment></div><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="light"?"light":"dark",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const s={src:"https://giscus.app/client.js","data-repo":"StephenLiu2/liu-log","data-repo-id":"R_kgDONwIeSw","data-category":"Announcements","data-category-id":"DIC_kwDONwIeS84CqBH_","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"zh-CN","data-loading":"lazy",crossorigin:"anonymous"},e=document.createElement("script");Object.entries(s).forEach(([t,n])=>e.setAttribute(t,n)),document.querySelector("#tw-comment").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme);const n=document.querySelector("#theme-toggle-float");n&&n.addEventListener("click",setGiscusTheme)})</script></article></main><footer class=footer><span>&copy; 2025 <a href=http://localhost:1313/>liu'log</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>